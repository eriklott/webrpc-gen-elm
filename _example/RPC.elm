module RPC exposing 
  ( Request
  , Status
  , EnvironmentCheck
  , Simple
  , User
  , Complex
  , TestApi
  , testApi  
  , webRpcVersion
  , webRpcSchemaVersion
  , webRpcSchemaHash
  , withBaseUrl
  , withCredentials
  , withTimeout
  , send
  )
  
  
{- 
    Test v0.10.0 46e43b970b1ab3d3401d05187a5454bb4823b30a
    --
    Code generated by webrpc-gen@v0.11.0 with custom generator. DO NOT EDIT.
    webrpc-gen -schema=test.ridl -target=../ -pkg=RPC -out=./RPC.elm
-}


import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Encode as Encode
import Time exposing (Posix)
import Dict exposting (Dict)
import Iso8601


webRpcVersion : String
webRpcVersion =
    "v1"


webRpcSchemaVersion : String
webRpcSchemaVersion =
    "v0.10.0"


webRpcSchemaHash : String
webRpcSchemaHash =
    "46e43b970b1ab3d3401d05187a5454bb4823b30a"


-- TYPES


type Status
    = StatusAVAILABLE
    | StatusNOT_AVAILABLE


type EnvironmentCheck
    = EnvironmentCheckProduction
    | EnvironmentCheckDevelopment


type alias Simple =
    { id : Int 
    , name : String 
    }


type alias User =
    { id : Int 
    , username : String 
    , role : String 
    , createdAt : Posix 
    , singleByte : String 
    , bytes : List String 
    }


type alias Complex =
    { meta : Dict String Decode.Value 
    , metaNestedExample : Dict String (Dict String Int) 
    , namesList : List String 
    , numsList : List Int 
    , doubleArray : List (List String) 
    , listOfMaps : List (Dict String Int) 
    , listOfUsers : List User 
    , mapOfUsers : Dict String User 
    , user : User 
    , enum : Status 
    , createdAt : Posix 
    , isActive : Bool 
    , metaOpt : Maybe (Dict String Decode.Value) 
    , metaNestedExampleOpt : Maybe (Dict String (Dict String Int)) 
    , namesListOpt : Maybe (List String) 
    , numsListOpt : Maybe (List Int) 
    , doubleArrayOpt : Maybe (List (List String)) 
    , listOfMapsOpt : Maybe (List (Dict String Int)) 
    , listOfUsersOpt : Maybe (List User) 
    , mapOfUsersOpt : Maybe (Dict String User) 
    , userOpt : Maybe User 
    , enumOpt : Maybe Status 
    , createdAtOpt : Maybe Posix 
    , isActiveOpt : Maybe Bool 
    , intmap : Dict Int Bool 
    }



-- SERVICES


type alias TestApi =
    { getEmpty : (Result Http.Error () -> msg) -> Request () msg
    , getError : (Result Http.Error () -> msg) -> Request () msg
    , getOne : (Result Http.Error Simple -> msg) -> Request Simple msg
    , sendOne : Simple -> (Result Http.Error () -> msg) -> Request () msg
    , getList : (Result Http.Error (List Int) -> msg) -> Request (List Int) msg
    , getMulti : (Result Http.Error { one : Simple, two : Simple, three : Maybe (List Simple), four : List Int } -> msg) -> Request { one : Simple, two : Simple, three : Maybe (List Simple), four : List Int } msg
    , sendMulti : Simple -> Simple -> Maybe Simple -> (Result Http.Error () -> msg) -> Request () msg
    , getComplex : (Result Http.Error Complex -> msg) -> Request Complex msg
    , sendComplex : Complex -> (Result Http.Error () -> msg) -> Request () msg
    , sendComplexArgs : Dict Int String -> (Result Http.Error () -> msg) -> Request () msg
    , getSchemaError : Int -> (Result Http.Error () -> msg) -> Request () msg
    }


testApi : TestApi
testApi =
    { getEmpty = testApiGetEmpty 
    , getError = testApiGetError 
    , getOne = testApiGetOne 
    , sendOne = testApiSendOne 
    , getList = testApiGetList 
    , getMulti = testApiGetMulti 
    , sendMulti = testApiSendMulti 
    , getComplex = testApiGetComplex 
    , sendComplex = testApiSendComplex 
    , sendComplexArgs = testApiSendComplexArgs 
    , getSchemaError = testApiGetSchemaError 
    }    
    
    
testApiGetEmpty : (Result Http.Error () -> msg) -> Request () msg
testApiGetEmpty toMsg =
    let
        encoder : Encode.Value
        encoder =
            Encode.object []

        decoder : Decoder ()
        decoder = 
            Decode.succeed ()
    in
    request
        { url = "/rpc/TestApi/GetEmpty"
        , encoder = encoder
        , decoder = decoder
        , toMsg = toMsg
        }


testApiGetError : (Result Http.Error () -> msg) -> Request () msg
testApiGetError toMsg =
    let
        encoder : Encode.Value
        encoder =
            Encode.object []

        decoder : Decoder ()
        decoder = 
            Decode.succeed ()
    in
    request
        { url = "/rpc/TestApi/GetError"
        , encoder = encoder
        , decoder = decoder
        , toMsg = toMsg
        }


testApiGetOne : (Result Http.Error Simple -> msg) -> Request Simple msg
testApiGetOne toMsg =
    let
        encoder : Encode.Value
        encoder =
            Encode.object []

        decoder : Decoder Simple
        decoder =
            Decode.field "one" simpleDecoder
    in
    request
        { url = "/rpc/TestApi/GetOne"
        , encoder = encoder
        , decoder = decoder
        , toMsg = toMsg
        }


testApiSendOne : Simple -> (Result Http.Error () -> msg) -> Request () msg
testApiSendOne one toMsg =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("one", simpleEncoder)
                ]

        decoder : Decoder ()
        decoder = 
            Decode.succeed ()
    in
    request
        { url = "/rpc/TestApi/SendOne"
        , encoder = encoder
        , decoder = decoder
        , toMsg = toMsg
        }


testApiGetList : (Result Http.Error (List Int) -> msg) -> Request (List Int) msg
testApiGetList toMsg =
    let
        encoder : Encode.Value
        encoder =
            Encode.object []

        decoder : Decoder (List Int)
        decoder =
            Decode.field "list" (Decode.list Decode.int)
    in
    request
        { url = "/rpc/TestApi/GetList"
        , encoder = encoder
        , decoder = decoder
        , toMsg = toMsg
        }


testApiGetMulti : (Result Http.Error { one : Simple, two : Simple, three : Maybe (List Simple), four : List Int } -> msg) -> Request { one : Simple, two : Simple, three : Maybe (List Simple), four : List Int } msg
testApiGetMulti toMsg =
    let
        encoder : Encode.Value
        encoder =
            Encode.object []

        decoder : Decoder { one : Simple, two : Simple, three : Maybe (List Simple), four : List Int }    
        decoder =
            Decode.succeed response
                |> andMap (Decode.field "one" simpleDecoder)
                |> andMap (Decode.field "two" simpleDecoder)
                |> andMap (decodeOptionalField "three" (Decode.list simpleDecoder))
                |> andMap (Decode.field "four" (Decode.list Decode.int))  

        response : Simple -> Simple -> Maybe (List Simple) -> List Int -> { one : Simple, two : Simple, three : Maybe (List Simple), four : List Int }
        response one two three four =
            { one = one, two = two, three = three, four = four }
    in
    request
        { url = "/rpc/TestApi/GetMulti"
        , encoder = encoder
        , decoder = decoder
        , toMsg = toMsg
        }


testApiSendMulti : Simple -> Simple -> Maybe Simple -> (Result Http.Error () -> msg) -> Request () msg
testApiSendMulti one two three toMsg =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("one", simpleEncoder)
                , ("two", simpleEncoder)
                , ("three", encodeMaybe simpleEncoder)
                ]

        decoder : Decoder ()
        decoder = 
            Decode.succeed ()
    in
    request
        { url = "/rpc/TestApi/SendMulti"
        , encoder = encoder
        , decoder = decoder
        , toMsg = toMsg
        }


testApiGetComplex : (Result Http.Error Complex -> msg) -> Request Complex msg
testApiGetComplex toMsg =
    let
        encoder : Encode.Value
        encoder =
            Encode.object []

        decoder : Decoder Complex
        decoder =
            Decode.field "complex" complexDecoder
    in
    request
        { url = "/rpc/TestApi/GetComplex"
        , encoder = encoder
        , decoder = decoder
        , toMsg = toMsg
        }


testApiSendComplex : Complex -> (Result Http.Error () -> msg) -> Request () msg
testApiSendComplex complex toMsg =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("complex", complexEncoder)
                ]

        decoder : Decoder ()
        decoder = 
            Decode.succeed ()
    in
    request
        { url = "/rpc/TestApi/SendComplex"
        , encoder = encoder
        , decoder = decoder
        , toMsg = toMsg
        }


testApiSendComplexArgs : Dict Int String -> (Result Http.Error () -> msg) -> Request () msg
testApiSendComplexArgs intMap toMsg =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("intMap", encodeDict identity Encode.string)
                ]

        decoder : Decoder ()
        decoder = 
            Decode.succeed ()
    in
    request
        { url = "/rpc/TestApi/SendComplexArgs"
        , encoder = encoder
        , decoder = decoder
        , toMsg = toMsg
        }


testApiGetSchemaError : Int -> (Result Http.Error () -> msg) -> Request () msg
testApiGetSchemaError code toMsg =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("code", Encode.int)
                ]

        decoder : Decoder ()
        decoder = 
            Decode.succeed ()
    in
    request
        { url = "/rpc/TestApi/GetSchemaError"
        , encoder = encoder
        , decoder = decoder
        , toMsg = toMsg
        }


-- REQUEST


type Request =
    Request response msg
        { url: String
        , decoder : Decoder msg
        , encoder : Encode.Value
        , toMsg : (Result Http.Error response -> msg)
        , baseUrl : String
        , withCredentials : Bool
        , timeout : Maybe Float
        }


newRequest : {url: String, decoder : Decoder msg, encoder : Encode.Value, toMsg : (Result Http.Error response -> msg)} -> Request response msg
newRequest { url, decoder, encoder, toMsg } =
    Request
        { url = url
        , decoder = decoder
        , encoder = encoder
        , toMsg = toMsg
        , baseUrl = ""
        , withCredentials = False
        , timeout = Just 3000
        }


withBaseUrl : String -> Request response msg -> Request response msg
withBaseUrl baseUrl request =
    { request | baseUrl = baseUrl }


withCredentials : Bool -> Request response msg -> Request request msg
withCredentials withCredentials request =
    { request | withCredentials = withCredentials }


withTimeout : Float -> Request response msg -> Request response msg
withTimeout timeout request =
    { request | timeout = Just timeout }


send : Request response msg -> Cmd msg
send request =
    let
        url =
            request.baseUrl ++ request.url

        body =
            request.encoder

        decoder =
            request.decoder

        toMsg =
            request.toMsg

        withCredentials =
            request.withCredentials

        timeout =
            request.timeout
    in
        Http.send toMsg
            { url = url
            , method = "POST"
            , headers = []
            , body = Http.jsonBody body
            , expect = Http.expectJson toMsg decoder
            , timeout = timeout
            , withCredentials = withCredentials
            }


-- DECODERS


statusDecoder : Decoder Status
statusDecoder =
    let
        enumDecoder : String -> Decoder Status
        enumDecoder str =
            case str of
                "AVAILABLE" -> 
                    Decode.succeed StatusAVAILABLE
                "NOT_AVAILABLE" -> 
                    Decode.succeed StatusNOT_AVAILABLE
                _ -> 
                    Decode.fail ("unknown value for type Status: " ++ str)
    in
    Decode.string |> Decode.andThen enumDecoder  


environmentCheckDecoder : Decoder EnvironmentCheck
environmentCheckDecoder =
    let
        enumDecoder : String -> Decoder EnvironmentCheck
        enumDecoder str =
            case str of
                "Production" -> 
                    Decode.succeed EnvironmentCheckProduction
                "Development" -> 
                    Decode.succeed EnvironmentCheckDevelopment
                _ -> 
                    Decode.fail ("unknown value for type EnvironmentCheck: " ++ str)
    in
    Decode.string |> Decode.andThen enumDecoder  


simpleDecoder : Decoder Simple
simpleDecoder =
    Decode.succeed Simple
        |> andMap (Decode.field "id" Decode.int)
        |> andMap (Decode.field "name" Decode.string)


userDecoder : Decoder User
userDecoder =
    Decode.succeed User
        |> andMap (Decode.field "id" Decode.int)
        |> andMap (Decode.field "USERNAME" Decode.string)
        |> andMap (Decode.field "role" Decode.string)
        |> andMap (Decode.field "createdAt" Iso8601.decoder)
        |> andMap (Decode.field "singleByte" Decode.string)
        |> andMap (Decode.field "bytes" (Decode.list Decode.string))


complexDecoder : Decoder Complex
complexDecoder =
    Decode.succeed Complex
        |> andMap (Decode.field "meta" (decodeDict Decode.string Decode.decodeValue))
        |> andMap (Decode.field "metaNestedExample" (decodeDict Decode.string (decodeDict Decode.string Decode.int)))
        |> andMap (Decode.field "namesList" (Decode.list Decode.string))
        |> andMap (Decode.field "numsList" (Decode.list Decode.int))
        |> andMap (Decode.field "doubleArray" (Decode.list (Decode.list Decode.string)))
        |> andMap (Decode.field "listOfMaps" (Decode.list (decodeDict Decode.string Decode.int)))
        |> andMap (Decode.field "listOfUsers" (Decode.list userDecoder))
        |> andMap (Decode.field "mapOfUsers" (decodeDict Decode.string userDecoder))
        |> andMap (Decode.field "user" userDecoder)
        |> andMap (Decode.field "enum" statusDecoder)
        |> andMap (Decode.field "createdAt" Iso8601.decoder)
        |> andMap (Decode.field "isActive" Decode.bool)
        |> andMap (decodeOptionalField "metaOpt" (decodeDict Decode.string Decode.decodeValue))
        |> andMap (decodeOptionalField "metaNestedExampleOpt" (decodeDict Decode.string (decodeDict Decode.string Decode.int)))
        |> andMap (decodeOptionalField "namesListOpt" (Decode.list Decode.string))
        |> andMap (decodeOptionalField "numsListOpt" (Decode.list Decode.int))
        |> andMap (decodeOptionalField "doubleArrayOpt" (Decode.list (Decode.list Decode.string)))
        |> andMap (decodeOptionalField "listOfMapsOpt" (Decode.list (decodeDict Decode.string Decode.int)))
        |> andMap (decodeOptionalField "listOfUsersOpt" (Decode.list userDecoder))
        |> andMap (decodeOptionalField "mapOfUsersOpt" (decodeDict Decode.string userDecoder))
        |> andMap (decodeOptionalField "userOpt" userDecoder)
        |> andMap (decodeOptionalField "enumOpt" statusDecoder)
        |> andMap (decodeOptionalField "createdAtOpt" Iso8601.decoder)
        |> andMap (decodeOptionalField "isActiveOpt" Decode.bool)
        |> andMap (Decode.field "intmap" (decodeDict Decode.int Decode.bool))


-- ENCODERS


statusEncoder : Status -> Encode.Value
statusEncoder status =
    case status of
        StatusAVAILABLE ->
            Encode.string "AVAILABLE"
        
        StatusNOT_AVAILABLE ->
            Encode.string "NOT_AVAILABLE"
        

environmentCheckEncoder : EnvironmentCheck -> Encode.Value
environmentCheckEncoder environmentCheck =
    case environmentCheck of
        EnvironmentCheckProduction ->
            Encode.string "Production"
        
        EnvironmentCheckDevelopment ->
            Encode.string "Development"
        

simpleEncoder : Simple -> Encode.Value
simpleEncoder simple =
    Encode.object
        [ ("id", Encode.int)
        , ("name", Encode.string)
        ]


userEncoder : User -> Encode.Value
userEncoder user =
    Encode.object
        [ ("id", Encode.int)
        , ("USERNAME", Encode.string)
        , ("role", Encode.string)
        , ("createdAt", Encode.posix)
        , ("singleByte", Encode.string)
        , ("bytes", Encode.list Encode.string)
        ]


complexEncoder : Complex -> Encode.Value
complexEncoder complex =
    Encode.object
        [ ("meta", encodeDict identity Encode.decodeValue)
        , ("metaNestedExample", encodeDict identity (encodeDict identity Encode.int))
        , ("namesList", Encode.list Encode.string)
        , ("numsList", Encode.list Encode.int)
        , ("doubleArray", Encode.list (Encode.list Encode.string))
        , ("listOfMaps", Encode.list (encodeDict identity Encode.int))
        , ("listOfUsers", Encode.list userEncoder)
        , ("mapOfUsers", encodeDict identity userEncoder)
        , ("user", userEncoder)
        , ("enum", statusEncoder)
        , ("createdAt", Encode.posix)
        , ("isActive", Encode.bool)
        , ("metaOpt", encodeMaybe (encodeDict identity Encode.decodeValue))
        , ("metaNestedExampleOpt", encodeMaybe (encodeDict identity (encodeDict identity Encode.int)))
        , ("namesListOpt", encodeMaybe (Encode.list Encode.string))
        , ("numsListOpt", encodeMaybe (Encode.list Encode.int))
        , ("doubleArrayOpt", encodeMaybe (Encode.list (Encode.list Encode.string)))
        , ("listOfMapsOpt", encodeMaybe (Encode.list (encodeDict identity Encode.int)))
        , ("listOfUsersOpt", encodeMaybe (Encode.list userEncoder))
        , ("mapOfUsersOpt", encodeMaybe (encodeDict identity userEncoder))
        , ("userOpt", encodeMaybe userEncoder)
        , ("enumOpt", encodeMaybe statusEncoder)
        , ("createdAtOpt", encodeMaybe Encode.posix)
        , ("isActiveOpt", encodeMaybe Encode.bool)
        , ("intmap", encodeDict identity Encode.bool)
        ]


-- HELPERS


andMap : Decoder a -> Decoder (a -> b) -> Decoder b
andMap =
    Decode.map2 (|>)


decodeOptionalField : String -> Decoder a -> Decoder (Maybe a)
decodeOptionalField fieldName decoder =
    let
        finishDecoding json =
            case Decode.decodeValue (Decode.field fieldName Decode.value) json of
                Ok val ->
                    Decode.map Just (Decode.field fieldName decoder)

                Err _ ->
                    Decode.succeed Nothing
    in
    Decode.oneOf
        [ Decode.field fieldName (Decode.null Nothing)
        , Decode.value |> Decode.andThen finishDecoding
        ]


decodeDict : Decoder comparable -> Decoder v -> Decoder (Dict comparable v)
decodeDict keyDecoder valueDecoder =
    keyValuePairs valueDecoder
        |> andThen (decodeDictFromTuples keyDecoder)


decodeDictFromTuples : Decoder comparable -> List ( String, v ) -> Decoder (Dict comparable v)
decodeDictFromTuples keyDecoder tuples =
    case tuples of
        [] ->
            succeed Dict.empty

        ( strKey, value ) :: rest ->
            case decodeString keyDecoder strKey of
                Ok key ->
                    decodeDictFromTuples keyDecoder rest
                        |> andThen (Dict.insert key value >> succeed)

                Err error ->
                    fail (errorToString error)    


encodeMaybe : (a -> Encode.Value) -> Maybe a -> Encode.Value
encodeMaybe encoder =
    Maybe.map encoder >> Maybe.withDefault Encode.null